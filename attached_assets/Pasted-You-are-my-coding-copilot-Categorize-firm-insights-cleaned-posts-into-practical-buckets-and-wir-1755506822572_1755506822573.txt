You are my coding copilot. Categorize firm “insights” (cleaned posts) into practical buckets and wire filters into the firm experiences page. Make idempotent, no new deps, and keep my current styling.

1) Create/overwrite categorizer.py (exact content)
# categorizer.py — lightweight rule-based classifier (stdlib only)
import re
from collections import defaultdict

# Slug -> display label
LABELS = {
    "application_timeline": "Application timeline",
    "selection_process": "Selection process",
    "offer_outcomes": "Offer outcomes",
    "program_structure": "Program structure",
    "pay_benefits": "Pay & benefits",
    "hours_workload": "Hours & workload",
    "culture_environment": "Culture & environment",
    "training_support": "Training & support",
    "secondments_mobility": "Secondments & mobility",
    "eligibility_requirements": "Eligibility & requirements",
    "interview_tips": "Interview tips",
}

# Keyword/regex signals per category (extend freely)
CATS = {
    "application_timeline": {
        "kw": ["open", "close", "deadline", "window", "applications", "intake", "by end", "cutoff"],
        "rx": [r"\b[A-Za-z]{3,9}\s+\d{4}\b", r"\b\d{1,2}\s*[/-]\s*\d{1,2}\s*[/-]\s*\d{2,4}\b"],
    },
    "selection_process": {
        "kw": ["online assessment", "oa", "vi", "video interview", "assessment centre", "assessment center",
               "ac", "case interview", "superday", "panel", "partner interview", "aptitude test"],
        "rx": [],
    },
    "offer_outcomes": {
        "kw": ["offer", "offers", "accepted", "rejected", "waitlist", "on hold", "conversion"],
        "rx": [],
    },
    "program_structure": {
        "kw": ["rotation", "rotations", "seat", "seats", "length", "18-month", "18 month", "12-month", "program"],
        "rx": [r"\b\d+\s+rotations?\b", r"\b\d+\s*(months?|yrs?|years?)\b"],
    },
    "pay_benefits": {
        "kw": ["salary", "pay", "super", "bonus", "overtime", "toil", "benefits", "allowance"],
        "rx": [r"\$[\d,]+", r"\b\d+\s*k\b"],
    },
    "hours_workload": {
        "kw": ["hours", "late", "weekend", "workload", "busy", "billable", "target", "utilisation", "utilization"],
        "rx": [r"\b\d{2}\+?\s*hours?\b", r"\b\d{3,4}\s*billable\b"],
    },
    "culture_environment": {
        "kw": ["culture", "supportive", "toxic", "nice", "collegial", "micromanage", "burnout", "team", "partners"],
        "rx": [],
    },
    "training_support": {
        "kw": ["mentor", "buddy", "training", "plt", "admission", "coaching", "feedback", "onboarding"],
        "rx": [],
    },
    "secondments_mobility": {
        "kw": ["secondment", "client secondment", "international", "rotation overseas", "relocation"],
        "rx": [],
    },
    "eligibility_requirements": {
        "kw": ["penultimate", "final year", "citizenship", "visa", "gpa", "credit average", "requirements"],
        "rx": [],
    },
    "interview_tips": {
        "kw": ["tip", "advice", "be ready", "expect", "my experience", "question was", "they asked"],
        "rx": [],
    },
}

def _score(text: str) -> dict:
    text_lc = text.lower()
    scores = defaultdict(float)
    for slug, spec in CATS.items():
        for k in spec["kw"]:
            if k in text_lc:
                scores[slug] += 1.0
        for pat in spec["rx"]:
            if re.search(pat, text_lc):
                scores[slug] += 1.5
    # cross-boosts
    if any(re.search(r"\$[\d,]+|\b\d+\s*k\b", text_lc) for _ in [0]):
        scores["pay_benefits"] += 0.5
    if "billable" in text_lc or "target" in text_lc:
        scores["hours_workload"] += 0.5
    if "rotation" in text_lc or "seat" in text_lc:
        scores["program_structure"] += 0.5
    return scores

def classify_text(text: str, threshold: float = 1.0, top_k: int = 3):
    """
    Returns (primary_slug, [slugs], details)
    - primary_slug: best category or None
    - slugs: all categories with score >= threshold (max top_k)
    - details: list of (slug, score) sorted desc
    """
    if not isinstance(text, str) or not text.strip():
        return None, [], []
    scores = _score(text)
    if not scores:
        return None, [], []
    ranked = sorted(scores.items(), key=lambda x: (-x[1], x[0]))
    kept = [(s, sc) for s, sc in ranked if sc >= threshold][:top_k]
    primary = kept[0][0] if kept else ranked[0][0]
    return primary, [s for s, _ in kept], kept

def label(slug: str) -> str:
    return LABELS.get(slug, slug.replace("_", " ").title())

2) Patch the firm experiences route to categorize on the fly

In the route that renders /experiences/<firm> (where you already load cleaned posts), import and use the classifier:

from categorizer import classify_text, label

# after you’ve built `items` (each item has at least `content`)
for it in items:
    p, cats, details = classify_text(it["content"], threshold=1.0, top_k=3)
    it["primary_cat"] = p
    it["cat_labels"] = [label(c) for c in cats]


Add a simple category filter via query string:

from flask import request

active_cat = request.args.get("cat")  # slug
if active_cat:
    items = [it for it in items if it.get("primary_cat") == active_cat or active_cat in [c.lower().replace(" ", "_") for c in it.get("cat_labels", [])]]


Build counts for chips:

from collections import Counter
cat_counts = Counter(it["primary_cat"] for it in items if it.get("primary_cat"))


Pass to template:

return render_template("experiences.html",
    firm_name=firm,
    items=items,
    cat_counts=cat_counts,
    active_cat=active_cat
)

3) Show category chips + tags in templates/experiences.html

At the top, under the page title, add filter chips (keep your existing classes):

{% if cat_counts %}
  <div class="mb-4 flex flex-wrap gap-2">
    <a href="?"
       class="px-2 py-1 rounded-full text-xs {{ 'bg-gray-900 text-white' if not active_cat else 'bg-gray-100 text-gray-700' }}">All</a>
    {% for slug, count in cat_counts.items() %}
      <a href="?cat={{ slug }}"
         class="px-2 py-1 rounded-full text-xs {{ 'bg-gray-900 text-white' if active_cat==slug else 'bg-gray-100 text-gray-700' }}">
         {{ slug.replace('_',' ') }} · {{ count }}
      </a>
    {% endfor %}
  </div>
{% endif %}


On each experience card, show tiny tags under the title/snippet:

{% if item.cat_labels %}
  <div class="mt-1 flex flex-wrap gap-1">
    {% for c in item.cat_labels %}
      <span class="px-2 py-0.5 rounded-full bg-gray-100 text-gray-700 text-[11px]">{{ c }}</span>
    {% endfor %}
  </div>
{% endif %}

4) (Optional) CLI script to pre-tag CSVs

Create categorize_insights.py to tag a CSV and write out a categorized file if you want offline processing:

# categorize_insights.py
import csv, sys
from categorizer import classify_text, label

def run(in_path, out_path):
    with open(in_path, newline="", encoding="utf-8") as f, open(out_path, "w", newline="", encoding="utf-8") as g:
        r = csv.DictReader(f)
        w = csv.DictWriter(g, fieldnames=r.fieldnames + ["primary_cat","cat_labels"])
        w.writeheader()
        for row in r:
            p, cats, _ = classify_text(row.get("content",""), threshold=1.0, top_k=3)
            row["primary_cat"] = p or ""
            row["cat_labels"] = ", ".join([label(c) for c in cats])
            w.writerow(row)

if __name__ == "__main__":
    in_path = sys.argv[1]; out_path = sys.argv[2]
    run(in_path, out_path)
    print("Wrote", out_path)


Keep everything else as-is (design, CSS, routes). No new packages.